"use strict";(self.webpackChunkangular_anb=self.webpackChunkangular_anb||[]).push([[4522],{58774:(wt,et,R)=>{R.d(et,{j:()=>A,b:()=>x});var K=R(15861),C=R(54346),o=R(8314);let w=null,z=null;function A(){return H.apply(this,arguments)}function H(){return(H=(0,K.Z)(function*(){return w||(w=t()),w})).apply(this,arguments)}function t(){return s.apply(this,arguments)}function s(){return(s=(0,K.Z)(function*(){z=yield((0,o.Z)("esri-csp-restrictions")?yield R.e(71).then(R.bind(R,10071)).then(h=>h.l):yield R.e(9507).then(R.bind(R,99507)).then(h=>h.l)).load({locateFile:()=>(0,C.V)("esri/core/libs/libtess/libtess.wasm")})})).apply(this,arguments)}function x(y,h){const i=Math.max(y.length,128e3);return z.triangulate(y,h,i)}},97938:(wt,et,R)=>{R.d(et,{E:()=>K});class K{constructor(o,c){this.x=o,this.y=c}clone(){return new K(this.x,this.y)}equals(o,c){return o===this.x&&c===this.y}isEqual(o){return o.x===this.x&&o.y===this.y}setCoords(o,c){this.x=o,this.y=c}normalize(){const o=this.x,c=this.y,w=Math.sqrt(o*o+c*c);this.x/=w,this.y/=w}rightPerpendicular(){const o=this.x;this.x=this.y,this.y=-o}move(o,c){this.x+=o,this.y+=c}assign(o){this.x=o.x,this.y=o.y}assignAdd(o,c){this.x=o.x+c.x,this.y=o.y+c.y}assignSub(o,c){this.x=o.x-c.x,this.y=o.y-c.y}rotate(o,c){const w=this.x,z=this.y;this.x=w*o-z*c,this.y=w*c+z*o}scale(o){this.x*=o,this.y*=o}length(){const o=this.x,c=this.y;return Math.sqrt(o*o+c*c)}static distance(o,c){const w=c.x-o.x,z=c.y-o.y;return Math.sqrt(w*w+z*z)}static add(o,c){return new K(o.x+c.x,o.y+c.y)}static sub(o,c){return new K(o.x-c.x,o.y-c.y)}}},47018:(wt,et,R)=>{R.d(et,{I:()=>z,b:()=>w});var K=R(39351),C=R(97938),o=R(43289);class c{constructor(t,s,x){this.ratio=t,this.x=s,this.y=x}}class w{constructor(t,s,x,y=8,h=8){this.lines=[],this.starts=[],this.validateTessellation=!0,this.pixelRatio=y,this.pixelMargin=h,this.tileSize=K.I_*y,this.dz=t,this.yPos=s,this.xPos=x}setPixelMargin(t){t!==this.pixelMargin&&(this.pixelMargin=t,this.setExtent(this._extent))}setExtent(t){this._extent=t,this.finalRatio=this.tileSize/t*(1<<this.dz);let s=this.pixelRatio*this.pixelMargin;s/=this.finalRatio;const x=t>>this.dz;s>x&&(s=x),this.margin=s,this.xmin=x*this.xPos-s,this.ymin=x*this.yPos-s,this.xmax=this.xmin+x+2*s,this.ymax=this.ymin+x+2*s}reset(t){this.type=t,this.lines=[],this.starts=[],this.line=null,this.start=0}moveTo(t,s){this._pushLine(),this._prevIsIn=this._isIn(t,s),this._moveTo(t,s,this._prevIsIn),this._prevPt=new C.E(t,s),this._firstPt=new C.E(t,s),this._dist=0}lineTo(t,s){const x=this._isIn(t,s),y=new C.E(t,s),h=C.E.distance(this._prevPt,y);let i,l,r,u,B,M,p,g;if(x)this._prevIsIn?this._lineTo(t,s,!0):(i=this._prevPt,l=y,r=this._intersect(l,i),this.start=this._dist+h*(1-this._r),this._lineTo(r.x,r.y,!0),this._lineTo(l.x,l.y,!0));else if(this._prevIsIn)l=this._prevPt,i=y,r=this._intersect(l,i),this._lineTo(r.x,r.y,!0),this._lineTo(i.x,i.y,!1);else{const a=this._prevPt,m=y;if(a.x<=this.xmin&&m.x<=this.xmin||a.x>=this.xmax&&m.x>=this.xmax||a.y<=this.ymin&&m.y<=this.ymin||a.y>=this.ymax&&m.y>=this.ymax)this._lineTo(m.x,m.y,!1);else{const f=[];if((a.x<this.xmin&&m.x>this.xmin||a.x>this.xmin&&m.x<this.xmin)&&(u=(this.xmin-a.x)/(m.x-a.x),g=a.y+u*(m.y-a.y),g<=this.ymin?M=!1:g>=this.ymax?M=!0:f.push(new c(u,this.xmin,g))),(a.x<this.xmax&&m.x>this.xmax||a.x>this.xmax&&m.x<this.xmax)&&(u=(this.xmax-a.x)/(m.x-a.x),g=a.y+u*(m.y-a.y),g<=this.ymin?M=!1:g>=this.ymax?M=!0:f.push(new c(u,this.xmax,g))),(a.y<this.ymin&&m.y>this.ymin||a.y>this.ymin&&m.y<this.ymin)&&(u=(this.ymin-a.y)/(m.y-a.y),p=a.x+u*(m.x-a.x),p<=this.xmin?B=!1:p>=this.xmax?B=!0:f.push(new c(u,p,this.ymin))),(a.y<this.ymax&&m.y>this.ymax||a.y>this.ymax&&m.y<this.ymax)&&(u=(this.ymax-a.y)/(m.y-a.y),p=a.x+u*(m.x-a.x),p<=this.xmin?B=!1:p>=this.xmax?B=!0:f.push(new c(u,p,this.ymax))),0===f.length)this._lineTo(B?this.xmax:this.xmin,M?this.ymax:this.ymin,!0);else if(f.length>1&&f[0].ratio>f[1].ratio)this.start=this._dist+h*f[1].ratio,this._lineTo(f[1].x,f[1].y,!0),this._lineTo(f[0].x,f[0].y,!0);else{this.start=this._dist+h*f[0].ratio;for(let _=0;_<f.length;_++)this._lineTo(f[_].x,f[_].y,!0)}this._lineTo(m.x,m.y,!1)}}this._dist+=h,this._prevIsIn=x,this._prevPt=y}close(){if(this.line.length>2){const t=this._firstPt,s=this._prevPt;t.x===s.x&&t.y===s.y||this.lineTo(t.x,t.y);const x=this.line;let y=x.length;for(;y>=4&&(x[0].x===x[1].x&&x[0].x===x[y-2].x||x[0].y===x[1].y&&x[0].y===x[y-2].y);)x.pop(),x[0].x=x[y-2].x,x[0].y=x[y-2].y,--y}}result(t=!0){return this._pushLine(),0===this.lines.length?null:(3===this.type&&t&&A.simplify(this.tileSize,this.margin*this.finalRatio,this.lines),this.lines)}resultWithStarts(){if(2!==this.type)throw new Error("Only valid for lines");this._pushLine();const t=this.lines,s=t.length;if(0===s)return null;const x=[];for(let y=0;y<s;y++)x.push({line:t[y],start:this.starts[y]||0});return x}_isIn(t,s){return t>=this.xmin&&t<=this.xmax&&s>=this.ymin&&s<=this.ymax}_intersect(t,s){let x,y,h;if(s.x>=this.xmin&&s.x<=this.xmax)y=s.y<=this.ymin?this.ymin:this.ymax,h=(y-t.y)/(s.y-t.y),x=t.x+h*(s.x-t.x);else if(s.y>=this.ymin&&s.y<=this.ymax)x=s.x<=this.xmin?this.xmin:this.xmax,h=(x-t.x)/(s.x-t.x),y=t.y+h*(s.y-t.y);else{y=s.y<=this.ymin?this.ymin:this.ymax,x=s.x<=this.xmin?this.xmin:this.xmax;const i=(x-t.x)/(s.x-t.x),l=(y-t.y)/(s.y-t.y);i<l?(h=i,y=t.y+i*(s.y-t.y)):(h=l,x=t.x+l*(s.x-t.x))}return this._r=h,new C.E(x,y)}_pushLine(){this.line&&(1===this.type?this.line.length>0&&(this.lines.push(this.line),this.starts.push(this.start)):2===this.type?this.line.length>1&&(this.lines.push(this.line),this.starts.push(this.start)):3===this.type&&this.line.length>3&&(this.lines.push(this.line),this.starts.push(this.start))),this.line=[],this.start=0}_moveTo(t,s,x){3!==this.type?x&&(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line.push(new C.E(t,s))):(x||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),s<this.ymin&&(s=this.ymin),s>this.ymax&&(s=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line.push(new C.E(t,s)),this._is_h=!1,this._is_v=!1)}_lineTo(t,s,x){let y,h;if(3!==this.type)if(x){if(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line.length>0&&(y=this.line[this.line.length-1],y.equals(t,s)))return;this.line.push(new C.E(t,s))}else this.line&&this.line.length>0&&this._pushLine();else if(x||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),s<this.ymin&&(s=this.ymin),s>this.ymax&&(s=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line&&this.line.length>0){y=this.line[this.line.length-1];const i=y.x===t,l=y.y===s;if(i&&l)return;this._is_h&&i||this._is_v&&l?(y.x=t,y.y=s,h=this.line[this.line.length-2],h.x===t&&h.y===s?(this.line.pop(),this.line.length<=1?(this._is_h=!1,this._is_v=!1):(h=this.line[this.line.length-2],this._is_h=h.x===t,this._is_v=h.y===s)):(this._is_h=h.x===t,this._is_v=h.y===s)):(this.line.push(new C.E(t,s)),this._is_h=i,this._is_v=l)}else this.line.push(new C.E(t,s))}}class z{setExtent(t){this._ratio=4096===t?1:4096/t}get validateTessellation(){return this._ratio<1}reset(t){this.lines=[],this.line=null}moveTo(t,s){this.line&&this.lines.push(this.line),this.line=[];const x=this._ratio;this.line.push(new C.E(t*x,s*x))}lineTo(t,s){const x=this._ratio;this.line.push(new C.E(t*x,s*x))}close(){const t=this.line;t&&!t[0].isEqual(t[t.length-1])&&t.push(t[0])}result(){return this.line&&this.lines.push(this.line),0===this.lines.length?null:this.lines}}class A{static simplify(t,s,x){if(!x)return;const y=-s,h=t+s,i=-s,l=t+s,r=[],u=[],B=x.length;for(let p=0;p<B;++p){const g=x[p];if(!g||g.length<2)continue;let a,m=g[0];const f=g.length;for(let _=1;_<f;++_)a=g[_],m.x===a.x&&(m.x<=y&&(m.y>a.y?(r.push(p),r.push(_),r.push(0),r.push(-1)):(u.push(p),u.push(_),u.push(0),u.push(-1))),m.x>=h&&(m.y<a.y?(r.push(p),r.push(_),r.push(1),r.push(-1)):(u.push(p),u.push(_),u.push(1),u.push(-1)))),m.y===a.y&&(m.y<=i&&(m.x<a.x?(r.push(p),r.push(_),r.push(2),r.push(-1)):(u.push(p),u.push(_),u.push(2),u.push(-1))),m.y>=l&&(m.x>a.x?(r.push(p),r.push(_),r.push(3),r.push(-1)):(u.push(p),u.push(_),u.push(3),u.push(-1)))),m=a}if(0===r.length||0===u.length)return;A.fillParent(x,u,r),A.fillParent(x,r,u);const M=[];A.calcDeltas(M,u,r),A.calcDeltas(M,r,u),A.addDeltas(M,x)}static fillParent(t,s,x){const y=x.length,h=s.length;for(let i=0;i<h;i+=4){const l=s[i],r=s[i+1],u=s[i+2],B=t[l][r-1],M=t[l][r];let p=8092,g=-1;for(let a=0;a<y;a+=4){if(x[a+2]!==u)continue;const m=x[a],f=x[a+1],_=t[m][f-1],E=t[m][f];switch(u){case 0:case 1:if((0,o.vX)(B.y,_.y,E.y)&&(0,o.vX)(M.y,_.y,E.y)){const d=Math.abs(E.y-_.y);d<p&&(p=d,g=a)}break;case 2:case 3:if((0,o.vX)(B.x,_.x,E.x)&&(0,o.vX)(M.x,_.x,E.x)){const d=Math.abs(E.x-_.x);d<p&&(p=d,g=a)}}}s[i+3]=g}}static calcDeltas(t,s,x){const y=s.length;for(let h=0;h<y;h+=4){const l=A.calcDelta(h,s,x,[]);t.push(s[h]),t.push(s[h+1]),t.push(s[h+2]),t.push(l)}}static calcDelta(t,s,x,y){const h=s[t+3];if(-1===h)return 0;const i=y.length;return i>1&&y[i-2]===h?0:(y.push(h),A.calcDelta(h,x,s,y)+1)}static addDeltas(t,s){const x=t.length;let y=0;for(let h=0;h<x;h+=4){const i=t[h+3];i>y&&(y=i)}for(let h=0;h<x;h+=4){const i=s[t[h]],l=t[h+1],r=y-t[h+3];switch(t[h+2]){case 0:i[l-1].x-=r,i[l].x-=r,1===l&&(i[i.length-1].x-=r),l===i.length-1&&(i[0].x-=r);break;case 1:i[l-1].x+=r,i[l].x+=r,1===l&&(i[i.length-1].x+=r),l===i.length-1&&(i[0].x+=r);break;case 2:i[l-1].y-=r,i[l].y-=r,1===l&&(i[i.length-1].y-=r),l===i.length-1&&(i[0].y-=r);break;case 3:i[l-1].y+=r,i[l].y+=r,1===l&&(i[i.length-1].y+=r),l===i.length-1&&(i[0].y+=r)}}}}},46519:(wt,et,R)=>{R.d(et,{z:()=>y});var K=R(39351);function C(h,i){return h.x===i.x&&h.y===i.y}function c(h,i){return h.x=i.y,h.y=-i.x,h}function w(h,i){return h.x=-i.y,h.y=i.x,h}function z(h,i){return h.x=i.x,h.y=i.y,h}function A(h,i){return h.x=-i.x,h.y=-i.y,h}function H(h){return Math.sqrt(h.x*h.x+h.y*h.y)}function t(h,i){return h.x*i.y-h.y*i.x}function s(h,i){return h.x*i.x+h.y*i.y}function x(h,i,l,r){return h.x=i.x*l+i.y*r,h.y=i.x*r-i.y*l,h}class y{constructor(i,l,r){this.writeVertex=i,this.writeTriangle=l,this.canUseThinTessellation=r,this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.textureNormalLeft={x:0,y:1},this.textureNormalRight={x:0,y:-1},this.textureNormal={x:void 0,y:void 0},this.joinNormal={x:void 0,y:void 0},this.inner={x:void 0,y:void 0},this.outer={x:void 0,y:void 0},this.roundStart={x:void 0,y:void 0},this.roundEnd={x:void 0,y:void 0},this.startBreak={x:void 0,y:void 0},this.endBreak={x:void 0,y:void 0},this.innerPrev={x:void 0,y:void 0},this.innerNext={x:void 0,y:void 0},this.bevelStart={x:void 0,y:void 0},this.bevelEnd={x:void 0,y:void 0},this.bevelMiddle={x:void 0,y:void 0}}tessellate(i,l){(function o(h){if(!h)return;const i=h.length;if(i<=1)return;let l=0;for(let r=1;r<i;r++)C(h[r],h[l])||++l===r||(h[l]=h[r]);h.length=l+1})(i),this.canUseThinTessellation&&l.halfWidth<K.tQ&&!l.offset?this.tessellateThin_(i,l):this.tessellate_(i,l)}tessellateThin_(i,l){if(i.length<2)return;const r=l.wrapDistance||65535;let u=l.initialDistance||0,B=!1,M=i[0].x,p=i[0].y;const g=i.length;for(let a=1;a<g;++a){B&&(B=!1,u=0);let m=i[a].x,f=i[a].y,_=m-M,E=f-p,d=Math.sqrt(_*_+E*E);if(_/=d,E/=d,u+d>r){B=!0;const e=(r-u)/d;d=r-u,m=(1-e)*M+e*m,f=(1-e)*p+e*f,--a}const b=this.writeVertex(M,p,0,0,_,E,E,-_,0,-1,u),X=this.writeVertex(M,p,0,0,_,E,-E,_,0,1,u);u+=d;const ht=this.writeVertex(m,f,0,0,_,E,E,-_,0,-1,u),n=this.writeVertex(m,f,0,0,_,E,-E,_,0,1,u);this.writeTriangle(b,X,ht),this.writeTriangle(X,ht,n),M=m,p=f}}tessellate_(i,l){const u=i[i.length-1],B=C(i[0],u);if(i.length<(B?3:2))return;const p=l.pixelCoordRatio,g=null!=l.capType?l.capType:0,a=null!=l.joinType?l.joinType:2,m=null!=l.miterLimit?Math.min(l.miterLimit,4):2,f=null!=l.roundLimit?Math.min(l.roundLimit,1.05):1.05,_=null!=l.halfWidth?l.halfWidth:2,E=!!l.textured;let d,b,X=null,ht=null;const n=this.prevNormal,e=this.nextNormal;let lt=-1,tt=-1;const T=this.joinNormal;let I,L;const ct=this.textureNormalLeft,mt=this.textureNormalRight,O=this.textureNormal;let k=-1,P=-1;const Tt=l.wrapDistance||65535;let D=l.initialDistance||0;const bt=this.writeVertex,Pt=this.writeTriangle,N=function(G,_t,nt,U,Q,J){const Y=bt(d,b,I,L,nt,U,G,_t,Q,J,D);return k>=0&&P>=0&&Y>=0&&Pt(k,P,Y),k=P,P=Y,Y};B&&(X=i[i.length-2],e.x=u.x-X.x,e.y=u.y-X.y,tt=H(e),e.x/=tt,e.y/=tt);let rt=!1;for(let G=0;G<i.length;++G){if(rt&&(rt=!1,D=0),X&&(n.x=-e.x,n.y=-e.y,lt=tt,D+lt>Tt&&(rt=!0)),rt){const v=(Tt-D)/lt;lt=Tt-D,X={x:(1-v)*X.x+v*i[G].x,y:(1-v)*X.y+v*i[G].y},--G}else X=i[G];d=X.x,b=X.y;const _t=G<=0&&!rt,nt=G===i.length-1;if(_t||(D+=lt),ht=nt?B?i[1]:null:i[G+1],ht?(e.x=ht.x-d,e.y=ht.y-b,tt=H(e),e.x/=tt,e.y/=tt):(e.x=void 0,e.y=void 0),!B){if(_t){w(T,e),I=T.x,L=T.y,2===g&&(N(-e.y-e.x,e.x-e.y,e.x,e.y,0,-1),N(e.y-e.x,-e.x-e.y,e.x,e.y,0,1)),1===g&&(N(-e.y-e.x,e.x-e.y,e.x,e.y,-1,-1),N(e.y-e.x,-e.x-e.y,e.x,e.y,-1,1)),1!==g&&0!==g||(N(-e.y,e.x,e.x,e.y,0,-1),N(e.y,-e.x,e.x,e.y,0,1));continue}if(nt){c(T,n),I=T.x,L=T.y,1!==g&&0!==g||(N(n.y,-n.x,-n.x,-n.y,0,-1),N(-n.y,n.x,-n.x,-n.y,0,1)),2===g&&(N(n.y-n.x,-n.x-n.y,-n.x,-n.y,0,-1),N(-n.y-n.x,n.x-n.y,-n.x,-n.y,0,1)),1===g&&(N(n.y-n.x,-n.x-n.y,-n.x,-n.y,1,-1),N(-n.y-n.x,n.x-n.y,-n.x,-n.y,1,1));continue}}let U,Q,J=-t(n,e);if(Math.abs(J)<.01)s(n,e)>0?(T.x=n.x,T.y=n.y,J=1,U=Number.MAX_VALUE,Q=!0):(w(T,e),J=1,U=1,Q=!1);else{T.x=(n.x+e.x)/J,T.y=(n.y+e.y)/J,U=H(T);const v=(U-1)*_*p;Q=U>4||v>lt&&v>tt}I=T.x,L=T.y;let Y=a;switch(a){case 0:U<1.05&&(Y=2);break;case 1:U<f&&(Y=2);break;case 2:U>m&&(Y=0)}switch(Y){case 2:if(N(T.x,T.y,-n.x,-n.y,0,-1),N(-T.x,-T.y,-n.x,-n.y,0,1),nt)break;if(E){const v=rt?0:D;k=this.writeVertex(d,b,I,L,e.x,e.y,T.x,T.y,0,-1,v),P=this.writeVertex(d,b,I,L,e.x,e.y,-T.x,-T.y,0,1,v)}break;case 0:{const v=J<0;let j,W,it,F;if(v){const V=k;k=P,P=V,j=ct,W=mt}else j=mt,W=ct;if(Q)it=v?w(this.innerPrev,n):c(this.innerPrev,n),F=v?c(this.innerNext,e):w(this.innerNext,e);else{const V=v?A(this.inner,T):z(this.inner,T);it=V,F=V}const Z=v?c(this.bevelStart,n):w(this.bevelStart,n);N(it.x,it.y,-n.x,-n.y,j.x,j.y);const pt=N(Z.x,Z.y,-n.x,-n.y,W.x,W.y);if(nt)break;const $=v?w(this.bevelEnd,e):c(this.bevelEnd,e);if(Q){const V=this.writeVertex(d,b,I,L,-n.x,-n.y,0,0,0,0,D);k=this.writeVertex(d,b,I,L,e.x,e.y,F.x,F.y,j.x,j.y,D),P=this.writeVertex(d,b,I,L,e.x,e.y,$.x,$.y,W.x,W.y,D),this.writeTriangle(pt,V,P)}else{if(E){const V=this.bevelMiddle;V.x=(Z.x+$.x)/2,V.y=(Z.y+$.y)/2,x(O,V,-n.x,-n.y),N(V.x,V.y,-n.x,-n.y,O.x,O.y),x(O,V,e.x,e.y),k=this.writeVertex(d,b,I,L,e.x,e.y,V.x,V.y,O.x,O.y,D),P=this.writeVertex(d,b,I,L,e.x,e.y,F.x,F.y,j.x,j.y,D)}else{const V=k;k=P,P=V}N($.x,$.y,e.x,e.y,W.x,W.y)}if(v){const V=k;k=P,P=V}break}case 1:{const v=J<0;let j,W;if(v){const S=k;k=P,P=S,j=ct,W=mt}else j=mt,W=ct;const it=v?A(this.inner,T):z(this.inner,T);let F,Z;Q?(F=v?w(this.innerPrev,n):c(this.innerPrev,n),Z=v?c(this.innerNext,e):w(this.innerNext,e)):(F=it,Z=it);const pt=v?c(this.roundStart,n):w(this.roundStart,n),$=v?w(this.roundEnd,e):c(this.roundEnd,e),V=N(F.x,F.y,-n.x,-n.y,j.x,j.y),dt=N(pt.x,pt.y,-n.x,-n.y,W.x,W.y);if(nt)break;const st=this.writeVertex(d,b,I,L,-n.x,-n.y,0,0,0,0,D);Q||this.writeTriangle(k,P,st);const q=A(this.outer,it),xt=this.writeVertex(d,b,I,L,e.x,e.y,$.x,$.y,W.x,W.y,D);let yt,at;const ft=U>2;if(ft){let S;U!==Number.MAX_VALUE?(q.x/=U,q.y/=U,S=s(n,q),S=(U*(S*S-1)+1)/S):S=-1,yt=v?c(this.startBreak,n):w(this.startBreak,n),yt.x+=n.x*S,yt.y+=n.y*S,at=v?w(this.endBreak,e):c(this.endBreak,e),at.x+=e.x*S,at.y+=e.y*S}x(O,q,-n.x,-n.y);const gt=this.writeVertex(d,b,I,L,-n.x,-n.y,q.x,q.y,O.x,O.y,D);x(O,q,e.x,e.y);const Et=E?this.writeVertex(d,b,I,L,e.x,e.y,q.x,q.y,O.x,O.y,D):gt,Mt=st,vt=E?this.writeVertex(d,b,I,L,e.x,e.y,0,0,0,0,D):st;let ot=-1,ut=-1;if(ft&&(x(O,yt,-n.x,-n.y),ot=this.writeVertex(d,b,I,L,-n.x,-n.y,yt.x,yt.y,O.x,O.y,D),x(O,at,e.x,e.y),ut=this.writeVertex(d,b,I,L,e.x,e.y,at.x,at.y,O.x,O.y,D)),E?ft?(this.writeTriangle(Mt,dt,ot),this.writeTriangle(Mt,ot,gt),this.writeTriangle(vt,Et,ut),this.writeTriangle(vt,ut,xt)):(this.writeTriangle(Mt,dt,gt),this.writeTriangle(vt,Et,xt)):ft?(this.writeTriangle(st,dt,ot),this.writeTriangle(st,ot,ut),this.writeTriangle(st,ut,xt)):(this.writeTriangle(st,dt,gt),this.writeTriangle(st,Et,xt)),Q?(k=this.writeVertex(d,b,I,L,e.x,e.y,Z.x,Z.y,j.x,j.y,D),P=xt):(k=E?this.writeVertex(d,b,I,L,e.x,e.y,Z.x,Z.y,j.x,j.y,D):V,this.writeTriangle(k,vt,xt),P=xt),v){const S=k;k=P,P=S}break}}}}}}}]);