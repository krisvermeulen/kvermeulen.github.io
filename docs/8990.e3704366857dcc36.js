"use strict";var Ke=Object.defineProperty,We=Object.defineProperties,He=Object.getOwnPropertyDescriptors,Ze=Object.getOwnPropertySymbols,Je=Object.prototype.hasOwnProperty,Xe=Object.prototype.propertyIsEnumerable,Ve=(q,V,S)=>V in q?Ke(q,V,{enumerable:!0,configurable:!0,writable:!0,value:S}):q[V]=S,le=(q,V)=>{for(var S in V||(V={}))Je.call(V,S)&&Ve(q,S,V[S]);if(Ze)for(var S of Ze(V))Xe.call(V,S)&&Ve(q,S,V[S]);return q},Ge=(q,V)=>We(q,He(V));(self.webpackChunkangular_anb=self.webpackChunkangular_anb||[]).push([[8990],{98148:(q,V,S)=>{function Z(H,G){const U=H.count;G||(G=new H.TypedArrayConstructor(U));for(let E=0;E<U;E++)G[E]=H.get(E);return G}S.d(V,{m:()=>Z}),Object.freeze({__proto__:null,copy:function B(H,G,U){const E=H.typedBuffer,M=H.typedBufferStride,T=G.typedBuffer,P=G.typedBufferStride,w=U?U.count:G.count;let R=(U&&U.dstIndex?U.dstIndex:0)*M,A=(U&&U.srcIndex?U.srcIndex:0)*P;for(let L=0;L<w;++L)E[R]=T[A],R+=M,A+=P},makeDense:Z})},35995:(q,V,S)=>{S.d(V,{f:()=>H,n:()=>W});var B=S(67866);function Z(U,E,M){const T=U.typedBuffer,P=U.typedBufferStride,w=E.typedBuffer,R=E.typedBufferStride,A=M?M.count:E.count;let L=(M&&M.dstIndex?M.dstIndex:0)*P,D=(M&&M.srcIndex?M.srcIndex:0)*R;for(let K=0;K<A;++K)T[L]=w[D],T[L+1]=w[D+1],L+=P,D+=R}function W(U,E,M){const T=U.typedBuffer,P=U.typedBufferStride,w=E.typedBuffer,R=E.typedBufferStride,A=M?M.count:E.count;let L=(M&&M.dstIndex?M.dstIndex:0)*P,D=(M&&M.srcIndex?M.srcIndex:0)*R;if((0,B.U)(E.elementType)){const K=(0,B.Op)(E.elementType);if((0,B.B3)(E.elementType))for(let N=0;N<A;++N)T[L]=Math.max(w[D]/K,-1),T[L+1]=Math.max(w[D+1]/K,-1),L+=P,D+=R;else for(let N=0;N<A;++N)T[L]=w[D]/K,T[L+1]=w[D+1]/K,L+=P,D+=R}else Z(U,E,M);return U}function H(U,E,M,T){var P,w;const R=U.typedBuffer,A=U.typedBufferStride,L=null!=(P=null==T?void 0:T.count)?P:U.count;let D=(null!=(w=null==T?void 0:T.dstIndex)?w:0)*A;for(let K=0;K<L;++K)R[D]=E,R[D+1]=M,D+=A}Object.freeze({__proto__:null,copy:Z,normalizeIntegerBuffer:W,fill:H})},63657:(q,V,S)=>{S.d(V,{a:()=>G,s:()=>H,t:()=>W});var B=S(96286);function W(E,M,T){if(E.count!==M.count)return void B.k.error("source and destination buffers need to have the same number of elements");const P=E.count,w=T[0],R=T[1],A=T[2],L=T[3],D=T[4],K=T[5],N=T[6],oe=T[7],J=T[8],Q=E.typedBuffer,ee=E.typedBufferStride,$=M.typedBuffer,_e=M.typedBufferStride;for(let xe=0;xe<P;xe++){const be=xe*ee,ye=xe*_e,de=$[ye],pe=$[ye+1],re=$[ye+2],Se=$[ye+3];Q[be]=w*de+L*pe+N*re,Q[be+1]=R*de+D*pe+oe*re,Q[be+2]=A*de+K*pe+J*re,Q[be+3]=Se}}function H(E,M,T){const P=Math.min(E.count,M.count),w=E.typedBuffer,R=E.typedBufferStride,A=M.typedBuffer,L=M.typedBufferStride;for(let D=0;D<P;D++){const K=D*R,N=D*L;w[K]=T*A[N],w[K+1]=T*A[N+1],w[K+2]=T*A[N+2],w[K+3]=T*A[N+3]}}function G(E,M,T){const P=Math.min(E.count,M.count),w=E.typedBuffer,R=E.typedBufferStride,A=M.typedBuffer,L=M.typedBufferStride;for(let D=0;D<P;D++){const K=D*R,N=D*L;w[K]=A[N]>>T,w[K+1]=A[N+1]>>T,w[K+2]=A[N+2]>>T,w[K+3]=A[N+3]>>T}}Object.freeze({__proto__:null,transformMat4:function Z(E,M,T){if(E.count!==M.count)return void B.k.error("source and destination buffers need to have the same number of elements");const P=E.count,w=T[0],R=T[1],A=T[2],L=T[3],D=T[4],K=T[5],N=T[6],oe=T[7],J=T[8],Q=T[9],ee=T[10],$=T[11],_e=T[12],xe=T[13],be=T[14],ye=T[15],de=E.typedBuffer,pe=E.typedBufferStride,re=M.typedBuffer,Se=M.typedBufferStride;for(let Te=0;Te<P;Te++){const ce=Te*pe,we=Te*Se,ge=re[we],ve=re[we+1],ie=re[we+2],me=re[we+3];de[ce]=w*ge+D*ve+J*ie+_e*me,de[ce+1]=R*ge+K*ve+Q*ie+xe*me,de[ce+2]=A*ge+N*ve+ee*ie+be*me,de[ce+3]=L*ge+oe*ve+$*ie+ye*me}},transformMat3:W,scale:H,shiftRight:G})},63470:(q,V,S)=>{function B(H,G,U){const E=H.typedBuffer,M=H.typedBufferStride,T=G.typedBuffer,P=G.typedBufferStride,w=U?U.count:G.count;let R=(U&&U.dstIndex?U.dstIndex:0)*M,A=(U&&U.srcIndex?U.srcIndex:0)*P;for(let L=0;L<w;++L)E[R]=T[A],E[R+1]=T[A+1],E[R+2]=T[A+2],E[R+3]=T[A+3],R+=M,A+=P}function Z(H,G,U,E,M,T){var P,w;const R=H.typedBuffer,A=H.typedBufferStride,L=null!=(P=null==T?void 0:T.count)?P:H.count;let D=(null!=(w=null==T?void 0:T.dstIndex)?w:0)*A;for(let K=0;K<L;++K)R[D]=G,R[D+1]=U,R[D+2]=E,R[D+3]=M,D+=A}S.d(V,{c:()=>B,f:()=>Z}),Object.freeze({__proto__:null,copy:B,fill:Z})},4794:(q,V,S)=>{function B(){return[0,0,0,0]}function W(J,Q,ee,$){return[J,Q,ee,$]}function G(J,Q){return new Float64Array(J,Q,4)}function E(){return W(1,1,1,1)}function M(){return W(1,0,0,0)}function T(){return W(0,1,0,0)}function P(){return W(0,0,1,0)}function w(){return W(0,0,0,1)}S.d(V,{a:()=>G,c:()=>B,f:()=>W});const A=E(),L=M(),D=T(),K=P(),N=w();Object.freeze({__proto__:null,create:B,clone:function Z(J){return[J[0],J[1],J[2],J[3]]},fromValues:W,fromArray:function H(J){const Q=[0,0,0,0],ee=Math.min(4,J.length);for(let $=0;$<ee;++$)Q[$]=J[$];return Q},createView:G,zeros:function U(){return[0,0,0,0]},ones:E,unitX:M,unitY:T,unitZ:P,unitW:w,ZEROS:[0,0,0,0],ONES:A,UNIT_X:L,UNIT_Y:D,UNIT_Z:K,UNIT_W:N})},97535:(q,V,S)=>{S.d(V,{x:()=>Z});var B=S(79682);class Z{constructor(G){this.allocator=G,this._items=[],this._itemsPtr=0,this.grow()}get(){return 0===this._itemsPtr&&(0,B.Y)(()=>this.reset()),this._itemsPtr===this._items.length&&this.grow(),this._items[this._itemsPtr++]}reset(){const G=Math.min(3*Math.max(8,this._itemsPtr),this._itemsPtr+3*W);this._items.length=Math.min(G,this._items.length),this._itemsPtr=0}grow(){for(let G=0;G<Math.max(8,Math.min(this._items.length,W));G++)this._items.push(this.allocator())}}const W=1024},67866:(q,V,S)=>{function Z(U){switch(U){case"u8":case"i8":return 1;case"u16":case"i16":return 2;case"u32":case"i32":case"f32":return 4;case"f64":return 8;default:return}}function W(U){switch(U){case"u8":case"u16":case"u32":return!1;case"i8":case"i16":case"i32":case"f32":case"f64":return!0;default:return}}function H(U){switch(U){case"u8":case"u16":case"u32":case"i8":case"i16":case"i32":return!0;case"f32":case"f64":return!1;default:return}}function G(U){switch(U){case"u8":return 255;case"u16":return 65535;case"u32":return 4294967295;case"i8":return 127;case"i16":return 32767;case"i32":return 2147483647;case"f32":return 3402823e32;case"f64":return 179769e303;default:return}}S.d(V,{n1:()=>Z,U:()=>H,B3:()=>W,Op:()=>G}),S(8314)},60490:(q,V,S)=>{S.d(V,{gS:()=>P});var B=S(67866);function P(w,R){return new w(new ArrayBuffer(R*w.ElementCount*(0,B.n1)(w.ElementType)))}Object.freeze({__proto__:null,copy:function Z(w,R,A){const L=w.typedBuffer,D=w.typedBufferStride,K=R.typedBuffer,N=R.typedBufferStride,oe=A?A.count:R.count;let J=(A&&A.dstIndex?A.dstIndex:0)*D,Q=(A&&A.srcIndex?A.srcIndex:0)*N;for(let ee=0;ee<oe;++ee){for(let $=0;$<9;++$)L[J+$]=K[Q+$];J+=D,Q+=N}}}),Object.freeze({__proto__:null,copy:function H(w,R,A){const L=w.typedBuffer,D=w.typedBufferStride,K=R.typedBuffer,N=R.typedBufferStride,oe=A?A.count:R.count;let J=(A&&A.dstIndex?A.dstIndex:0)*D,Q=(A&&A.srcIndex?A.srcIndex:0)*N;for(let ee=0;ee<oe;++ee){for(let $=0;$<16;++$)L[J+$]=K[Q+$];J+=D,Q+=N}}}),S(98148),S(35995),S(9554),S(63470)},26242:(q,V,S)=>{S.d(V,{MP:()=>L,WM:()=>w});var B=S(79682),Z=S(550),W=S(43703),H=S(78451),G=S(99770),U=S(28093),E=S(4794);class M{constructor(N,oe,J){this.itemByteSize=N,this.itemCreate=oe,this._buffers=new Array,this._items=new Array,this._itemsPtr=0,this._itemsPerBuffer=Math.ceil(J/this.itemByteSize)}get(){0===this._itemsPtr&&(0,B.Y)(()=>this.reset());const N=Math.floor(this._itemsPtr/this._itemsPerBuffer);for(;this._buffers.length<=N;){const oe=new ArrayBuffer(this._itemsPerBuffer*this.itemByteSize);for(let J=0;J<this._itemsPerBuffer;++J)this._items.push(this.itemCreate(oe,J*this.itemByteSize));this._buffers.push(oe)}return this._items[this._itemsPtr++]}reset(){const N=2*(Math.floor(this._itemsPtr/this._itemsPerBuffer)+1);for(;this._buffers.length>N;)this._buffers.pop(),this._items.length=this._buffers.length*this._itemsPerBuffer;this._itemsPtr=0}static createVec2f64(N=T){return new M(16,G.c,N)}static createVec3f64(N=T){return new M(24,U.b,N)}static createVec4f64(N=T){return new M(32,E.a,N)}static createMat3f64(N=T){return new M(72,Z.a,N)}static createMat4f64(N=T){return new M(128,W.a,N)}static createQuatf64(N=T){return new M(32,H.c,N)}get test(){return{size:this._buffers.length*this._itemsPerBuffer*this.itemByteSize}}}const T=4096,w=(M.createVec2f64(),M.createVec3f64()),L=(M.createVec4f64(),M.createMat3f64(),M.createMat4f64());M.createQuatf64()},9160:(q,V,S)=>{S.d(V,{C:()=>M});var B=S(15861),Z=S(84792),W=S(59213),H=S(26584),G=S(62208),U=S(10699),E=S(21726);class M{constructor(w){this.streamDataRequester=w}loadJSON(w,R){var A=this;return(0,B.Z)(function*(){return A.load("json",w,R)})()}loadBinary(w,R){var A=this;return(0,B.Z)(function*(){return(0,E.HK)(w)?((0,U.k_)(R),(0,E.AH)(w)):A.load("binary",w,R)})()}loadImage(w,R){var A=this;return(0,B.Z)(function*(){return A.load("image",w,R)})()}load(w,R,A){var L=this;return(0,B.Z)(function*(){if((0,G.Wi)(L.streamDataRequester))return(yield(0,Z.default)(R,{responseType:T[w]})).data;const D=yield(0,W.q6)(L.streamDataRequester.request(R,w,A));if(!0===D.ok)return D.value;throw(0,U.r9)(D.error),new H.Z("",`Request for resource failed: ${D.error}`)})()}}const T={image:"image",binary:"array-buffer",json:"json"}},96170:(q,V,S)=>{S.d(V,{jX:()=>G,DA:()=>H,nh:()=>W});var B=S(55713),Z=S(73825);function W(U,E=Z.p){return"number"==typeof U?E(U):(0,B.Uc)(U)||(0,B.lq)(U)?new Uint32Array(U):U}function H(U){const E="number"==typeof U?U:U.length;if(E<3)return new Uint16Array(0);const M=E-2,T=M<=65536?new Uint16Array(3*M):new Uint32Array(3*M);if("number"==typeof U){let P=0;for(let w=0;w<M;w+=1)w%2==0?(T[P++]=w,T[P++]=w+1,T[P++]=w+2):(T[P++]=w+1,T[P++]=w,T[P++]=w+2)}else{let P=0;for(let w=0;w<M;w+=1)if(w%2==0){const A=U[w+1],L=U[w+2];T[P++]=U[w],T[P++]=A,T[P++]=L}else{const A=U[w],L=U[w+2];T[P++]=U[w+1],T[P++]=A,T[P++]=L}}return T}function G(U){const E="number"==typeof U?U:U.length;if(E<3)return new Uint16Array(0);const M=E-2,T=M<=65536?new Uint16Array(3*M):new Uint32Array(3*M);if("number"==typeof U){let P=0;for(let w=0;w<M;++w)T[P++]=0,T[P++]=w+1,T[P++]=w+2;return T}{const P=U[0];let w=U[1],R=0;for(let A=0;A<M;++A){const L=U[A+2];T[R++]=P,T[R++]=w,T[R++]=L,w=L}return T}}},31365:(q,V,S)=>{S.d(V,{z:()=>je});var B=S(15861),Z=S(62208),W=S(43703),H=S(26584);const U=S(63290).Z.getLogger("esri.views.3d.glTF");var P=S(94573),w=S(88159),R=S(21726),A=S(10349),L=S(28347),D=S(48977),K=S(78451),N=S(60479),oe=S(98148);class J{constructor(a){this.data=a,this.offset4=0,this.dataUint32=new Uint32Array(this.data,0,Math.floor(this.data.byteLength/4))}readUint32(){const a=this.offset4;return this.offset4+=1,this.dataUint32[a]}readUint8Array(a){const h=4*this.offset4;return this.offset4+=a/4,new Uint8Array(this.data,h,a)}remainingBytes(){return this.data.byteLength-4*this.offset4}}const Q={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1},ee={pbrMetallicRoughness:Q,emissiveFactor:[0,0,0],alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1},$={ESRI_externalColorMixMode:"tint"},_e=(x={})=>{const a=le(le({},Q),x.pbrMetallicRoughness),h=function xe(x){switch(x.ESRI_externalColorMixMode){case"multiply":case"tint":case"ignore":case"replace":break;default:(0,P.Bg)(x.ESRI_externalColorMixMode),x.ESRI_externalColorMixMode="tint"}return x}(le(le({},$),x.extras));return Ge(le(le({},ee),x),{pbrMetallicRoughness:a,extras:h})},be={magFilter:9729,minFilter:9987,wrapS:10497,wrapT:10497};class re{constructor(a,h,y,d,_){this.context=a,this.errorContext=h,this.uri=y,this.json=d,this.glbBuffer=_,this.bufferLoaders=new Map,this.textureLoaders=new Map,this.textureCache=new Map,this.materialCache=new Map,this.nodeParentMap=new Map,this.nodeTransformCache=new Map,this.baseUri=function de(x){let a,h;return x.replace(/^(.*\/)?([^/]*)$/,(y,d,_)=>(a=d||"",h=_||"","")),{dirPart:a,filePart:h}}(this.uri).dirPart,this.checkVersionSupported(),this.checkRequiredExtensionsSupported(),h.errorUnsupportedIf(null==d.scenes,"Scenes must be defined."),h.errorUnsupportedIf(null==d.meshes,"Meshes must be defined"),h.errorUnsupportedIf(null==d.nodes,"Nodes must be defined."),this.computeNodeParents()}static load(a,h,y,d){var _=this;return(0,B.Z)(function*(){if((0,R.HK)(y)){const z=(0,R.sJ)(y);if("model/gltf-binary"!==z.mediaType)try{const j=JSON.parse(z.isBase64?atob(z.data):z.data);return new re(a,h,y,j)}catch(j){}const k=(0,R.AH)(y);if(re.isGLBData(k))return _.fromGLBData(a,h,y,k)}if(y.endsWith(".gltf")){const z=yield a.loadJSON(y,d);return new re(a,h,y,z)}const b=yield a.loadBinary(y,d);if(re.isGLBData(b))return _.fromGLBData(a,h,y,b);const C=yield a.loadJSON(y,d);return new re(a,h,y,C)})()}static isGLBData(a){const h=new J(a);return h.remainingBytes()>=4&&1179937895===h.readUint32()}static fromGLBData(a,h,y,d){return(0,B.Z)(function*(){const _=yield re.parseGLBData(h,d);return new re(a,h,y,_.json,_.binaryData)})()}static parseGLBData(a,h){return(0,B.Z)(function*(){const y=new J(h);a.assert(y.remainingBytes()>=12,"GLB binary data is insufficiently large.");const d=y.readUint32(),_=y.readUint32(),b=y.readUint32();a.assert(1179937895===d,"Magic first 4 bytes do not fit to expected GLB value."),a.assert(h.byteLength>=b,"GLB binary data is smaller than header specifies."),a.errorUnsupportedIf(2!==_,"An unsupported GLB container version was detected. Only version 2 is supported.");let C,z,k=0;for(;y.remainingBytes()>=8;){const j=y.readUint32(),X=y.readUint32();0===k?(a.assert(1313821514===X,"First GLB chunk must be JSON."),a.assert(j>=0,"No JSON data found."),C=yield ie(y.readUint8Array(j))):1===k?(a.errorUnsupportedIf(5130562!==X,"Second GLB chunk expected to be BIN."),z=y.readUint8Array(j)):a.warnUnsupported("More than 2 GLB chunks detected. Skipping."),k+=1}return C||a.error("No GLB JSON chunk detected."),{json:C,binaryData:z}})()}getBuffer(a,h){var y=this;return(0,B.Z)(function*(){const d=y.json.buffers[a],_=y.errorContext;if(null==d.uri)return _.assert(null!=y.glbBuffer,"GLB buffer not present"),y.glbBuffer;const b=yield y.getBufferLoader(a,h);return _.assert(b.byteLength===d.byteLength,"Buffer byte lengths should match."),b})()}getBufferLoader(a,h){var y=this;return(0,B.Z)(function*(){const d=y.bufferLoaders.get(a);if(d)return d;const b=y.context.loadBinary(y.resolveUri(y.json.buffers[a].uri),h).then(C=>new Uint8Array(C));return y.bufferLoaders.set(a,b),b})()}getAccessor(a,h){var y=this;return(0,B.Z)(function*(){const d=y.errorContext;d.errorUnsupportedIf(!y.json.accessors,"Accessors missing.");const _=y.json.accessors[a];d.errorUnsupportedIf(null==(null==_?void 0:_.bufferView),"Some accessor does not specify a bufferView."),d.errorUnsupportedIf(_.type in["MAT2","MAT3","MAT4"],`AttributeType ${_.type} is not supported`);const b=y.json.bufferViews[_.bufferView],C=yield y.getBuffer(b.buffer,h),z=we[_.type],k=ge[_.componentType],j=z*k,X=b.byteStride||j;return{raw:C.buffer,byteStride:X,byteOffset:C.byteOffset+(b.byteOffset||0)+(_.byteOffset||0),entryCount:_.count,isDenselyPacked:X===j,componentCount:z,componentByteSize:k,componentType:_.componentType,min:_.min,max:_.max,normalized:!!_.normalized}})()}getIndexData(a,h){var y=this;return(0,B.Z)(function*(){if(null==a.indices)return null;const d=yield y.getAccessor(a.indices,h);if(d.isDenselyPacked)switch(d.componentType){case 5121:return new Uint8Array(d.raw,d.byteOffset,d.entryCount);case 5123:return new Uint16Array(d.raw,d.byteOffset,d.entryCount);case 5125:return new Uint32Array(d.raw,d.byteOffset,d.entryCount)}else switch(d.componentType){case 5121:return(0,oe.m)(y.wrapAccessor(N.D_,d));case 5123:return(0,oe.m)(y.wrapAccessor(N.av,d));case 5125:return(0,oe.m)(y.wrapAccessor(N.Nu,d))}})()}getPositionData(a,h){var y=this;return(0,B.Z)(function*(){const d=y.errorContext;d.errorUnsupportedIf(null==a.attributes.POSITION,"No POSITION vertex data found.");const _=yield y.getAccessor(a.attributes.POSITION,h);return d.errorUnsupportedIf(5126!==_.componentType,"Expected type FLOAT for POSITION vertex attribute, but found "+Me[_.componentType]),d.errorUnsupportedIf(3!==_.componentCount,"POSITION vertex attribute must have 3 components, but found "+_.componentCount.toFixed()),y.wrapAccessor(N.ct,_)})()}getNormalData(a,h){var y=this;return(0,B.Z)(function*(){const d=y.errorContext;d.assert(null!=a.attributes.NORMAL,"No NORMAL vertex data found.");const _=yield y.getAccessor(a.attributes.NORMAL,h);return d.errorUnsupportedIf(5126!==_.componentType,"Expected type FLOAT for NORMAL vertex attribute, but found "+Me[_.componentType]),d.errorUnsupportedIf(3!==_.componentCount,"NORMAL vertex attribute must have 3 components, but found "+_.componentCount.toFixed()),y.wrapAccessor(N.ct,_)})()}getTangentData(a,h){var y=this;return(0,B.Z)(function*(){const d=y.errorContext;d.assert(null!=a.attributes.TANGENT,"No TANGENT vertex data found.");const _=yield y.getAccessor(a.attributes.TANGENT,h);return d.errorUnsupportedIf(5126!==_.componentType,"Expected type FLOAT for TANGENT vertex attribute, but found "+Me[_.componentType]),d.errorUnsupportedIf(4!==_.componentCount,"TANGENT vertex attribute must have 4 components, but found "+_.componentCount.toFixed()),new N.ek(_.raw,_.byteOffset,_.byteStride,_.byteOffset+_.byteStride*_.entryCount)})()}getTextureCoordinates(a,h){var y=this;return(0,B.Z)(function*(){const d=y.errorContext;d.assert(null!=a.attributes.TEXCOORD_0,"No TEXCOORD_0 vertex data found.");const _=yield y.getAccessor(a.attributes.TEXCOORD_0,h);return d.errorUnsupportedIf(2!==_.componentCount,"TEXCOORD_0 vertex attribute must have 2 components, but found "+_.componentCount.toFixed()),5126===_.componentType?y.wrapAccessor(N.Eu,_):(d.errorUnsupportedIf(!_.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0."),function ve(x){switch(x.componentType){case 5120:return new N.Vs(x.raw,x.byteOffset,x.byteStride,x.byteOffset+x.byteStride*x.entryCount);case 5121:return new N.xA(x.raw,x.byteOffset,x.byteStride,x.byteOffset+x.byteStride*x.entryCount);case 5122:return new N.or(x.raw,x.byteOffset,x.byteStride,x.byteOffset+x.byteStride*x.entryCount);case 5123:return new N.TS(x.raw,x.byteOffset,x.byteStride,x.byteOffset+x.byteStride*x.entryCount);case 5125:return new N.qt(x.raw,x.byteOffset,x.byteStride,x.byteOffset+x.byteStride*x.entryCount);case 5126:return new N.Eu(x.raw,x.byteOffset,x.byteStride,x.byteOffset+x.byteStride*x.entryCount);default:return void(0,P.Bg)(x.componentType)}}(_))})()}getVertexColors(a,h){var y=this;return(0,B.Z)(function*(){const d=y.errorContext;d.assert(null!=a.attributes.COLOR_0,"No COLOR_0 vertex data found.");const _=yield y.getAccessor(a.attributes.COLOR_0,h);if(d.errorUnsupportedIf(4!==_.componentCount&&3!==_.componentCount,"COLOR_0 attribute must have 3 or 4 components, but found "+_.componentCount.toFixed()),4===_.componentCount){if(5126===_.componentType)return y.wrapAccessor(N.ek,_);if(5121===_.componentType)return y.wrapAccessor(N.mc,_);if(5123===_.componentType)return y.wrapAccessor(N.v6,_)}else if(3===_.componentCount){if(5126===_.componentType)return y.wrapAccessor(N.ct,_);if(5121===_.componentType)return y.wrapAccessor(N.ne,_);if(5123===_.componentType)return y.wrapAccessor(N.mw,_)}d.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+Me[_.componentType])})()}hasPositions(a){return void 0!==a.attributes.POSITION}hasNormals(a){return void 0!==a.attributes.NORMAL}hasVertexColors(a){return void 0!==a.attributes.COLOR_0}hasTextureCoordinates(a){return void 0!==a.attributes.TEXCOORD_0}hasTangents(a){return void 0!==a.attributes.TANGENT}getMaterial(a,h,y){var d=this;return(0,B.Z)(function*(){let _=d.materialCache.get(a.material);if(!_){const b=null!=a.material?_e(d.json.materials[a.material]):_e(),C=b.pbrMetallicRoughness,z=d.hasVertexColors(a),k=d.getTexture(C.baseColorTexture,h),j=d.getTexture(b.normalTexture,h),X=y?d.getTexture(b.occlusionTexture,h):null,Y=y?d.getTexture(b.emissiveTexture,h):null,ne=y?d.getTexture(C.metallicRoughnessTexture,h):null,se=null!=a.material?a.material:-1;_={alphaMode:b.alphaMode,alphaCutoff:b.alphaCutoff,color:C.baseColorFactor,doubleSided:!!b.doubleSided,colorTexture:yield k,normalTexture:yield j,name:b.name,id:se,occlusionTexture:yield X,emissiveTexture:yield Y,emissiveFactor:b.emissiveFactor,metallicFactor:C.metallicFactor,roughnessFactor:C.roughnessFactor,metallicRoughnessTexture:yield ne,vertexColors:z,ESRI_externalColorMixMode:b.extras.ESRI_externalColorMixMode}}return _})()}getTexture(a,h){var y=this;return(0,B.Z)(function*(){if(!a)return null;y.errorContext.errorUnsupportedIf(0!==(a.texCoord||0),"Only TEXCOORD with index 0 is supported.");const d=a.index,_=y.errorContext,b=y.json.textures[d],C=(x=null!=b.sampler?y.json.samplers[b.sampler]:{},le(le({},be),x));var x;_.errorUnsupportedIf(null==b.source,"Source is expected to be defined for a texture.");const z=y.json.images[b.source],k=yield y.loadTextureImageData(d,b,h);return(0,w.s1)(y.textureCache,d,()=>{const j=Y=>33071===Y||33648===Y||10497===Y,X=Y=>(_.error(`Unexpected TextureSampler WrapMode: ${Y}. Using default REPEAT(10497).`),10497);return{data:k,wrapS:j(C.wrapS)?C.wrapS:X(C.wrapS),wrapT:j(C.wrapT)?C.wrapT:X(C.wrapT),minFilter:C.minFilter,name:z.name,id:d}})})()}getNodeTransform(a){if(void 0===a)return Te;let h=this.nodeTransformCache.get(a);if(!h){const y=this.getNodeTransform(this.getNodeParent(a)),d=this.json.nodes[a];d.matrix?h=(0,L.m)((0,W.c)(),y,d.matrix):d.translation||d.rotation||d.scale?(h=(0,W.b)(y),d.translation&&(0,L.a)(h,h,d.translation),d.rotation&&(ce[3]=(0,D.g)(ce,d.rotation),(0,L.e)(h,h,ce[3],ce)),d.scale&&(0,L.f)(h,h,d.scale)):h=y,this.nodeTransformCache.set(a,h)}return h}wrapAccessor(a,h){return new a(h.raw,h.byteOffset,h.byteStride,h.byteOffset+h.byteStride*(h.entryCount-1)+h.componentByteSize*h.componentCount)}resolveUri(a){return(0,R.hF)(a,this.baseUri)}getNodeParent(a){return this.nodeParentMap.get(a)}checkVersionSupported(){const a=A.G.parse(this.json.asset.version,"glTF");Se.validate(a)}checkRequiredExtensionsSupported(){const a=this.json;a.extensionsRequired&&0!==a.extensionsRequired.length&&this.errorContext.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+a.extensionsRequired.join(", "))}computeNodeParents(){this.json.nodes.forEach((a,h)=>{a.children&&a.children.forEach(y=>{this.nodeParentMap.set(y,h)})})}loadTextureImageData(a,h,y){var d=this;return(0,B.Z)(function*(){const _=d.textureLoaders.get(a);if(_)return _;const b=d.createTextureLoader(h,y);return d.textureLoaders.set(a,b),b})()}createTextureLoader(a,h){var y=this;return(0,B.Z)(function*(){const d=y.json.images[a.source];if(d.uri)return y.context.loadImage(y.resolveUri(d.uri),h);const _=y.errorContext;_.errorUnsupportedIf(null==d.bufferView,"Image bufferView must be defined."),_.errorUnsupportedIf(null==d.mimeType,"Image mimeType must be defined.");const b=y.json.bufferViews[d.bufferView],C=yield y.getBuffer(b.buffer,h);return _.errorUnsupportedIf(null!=b.byteStride,"byteStride not supported for image buffer"),function Ue(x,a){return Ie.apply(this,arguments)}(new Uint8Array(C.buffer,C.byteOffset+(b.byteOffset||0),b.byteLength),d.mimeType)})()}}const Se=new A.G(2,0,"glTF"),Te=(0,L.u)((0,W.c)(),Math.PI/2),ce=(0,K.a)(),we={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},ge={5120:1,5121:1,5122:2,5123:2,5126:4,5125:4};function ie(x){return me.apply(this,arguments)}function me(){return(me=(0,B.Z)(function*(x){return new Promise((a,h)=>{const y=new Blob([x]),d=new FileReader;d.onload=()=>{a(JSON.parse(d.result))},d.onerror=_=>{h(_)},d.readAsText(y)})})).apply(this,arguments)}function Ie(){return(Ie=(0,B.Z)(function*(x,a){return new Promise((h,y)=>{const d=new Blob([x],{type:a}),_=URL.createObjectURL(d),b=new Image;b.addEventListener("load",()=>{URL.revokeObjectURL(_),"decode"in b?b.decode().then(()=>h(b),()=>h(b)):h(b)}),b.addEventListener("error",C=>{URL.revokeObjectURL(_),y(C)}),b.src=_})})).apply(this,arguments)}const Me={5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5125:"UNSIGNED_INT",5126:"FLOAT"};let De=0;function je(x,a){return Le.apply(this,arguments)}function Le(){return Le=(0,B.Z)(function*(x,a,h={},y=!0){const d=yield re.load(x,O,a,h),_="gltf_"+De++,b={lods:[],materials:new Map,textures:new Map,meta:te(d)},C=!(!d.json.asset.extras||"symbolResource"!==d.json.asset.extras.ESRI_type),z=new Map;yield he(d,function(){var k=(0,B.Z)(function*(j,X,Y,ne){var se;const fe=null!=(se=z.get(Y))?se:0;z.set(Y,fe+1);const ae=void 0!==j.mode?j.mode:4,Be=4===ae||5===ae||6===ae?ae:null;if((0,Z.Wi)(Be))return void O.warnUnsupported("Unsupported primitive mode ("+F[ae]+"). Skipping primitive.");if(!d.hasPositions(j))return void O.warn("Skipping primitive without POSITION vertex attribute.");const Ce=d.getPositionData(j,h),Ae=d.getMaterial(j,h,y),Ee=d.hasNormals(j)?d.getNormalData(j,h):null,Re=d.hasTangents(j)?d.getTangentData(j,h):null,Ne=d.hasTextureCoordinates(j)?d.getTextureCoordinates(j,h):null,Pe=d.hasVertexColors(j)?d.getVertexColors(j,h):null,ze=d.getIndexData(j,h),ke={transform:(0,W.b)(X),attributes:{position:yield Ce,normal:Ee?yield Ee:null,texCoord0:Ne?yield Ne:null,color:Pe?yield Pe:null,tangent:Re?yield Re:null},indices:yield ze,primitiveType:Be,material:v(b,yield Ae,_)};let Fe=null;(0,Z.pC)(b.meta)&&(0,Z.pC)(b.meta.ESRI_lod)&&"screenSpaceRadius"===b.meta.ESRI_lod.metric&&(Fe=b.meta.ESRI_lod.thresholds[Y]),b.lods[Y]=b.lods[Y]||{parts:[],name:ne,lodThreshold:Fe},b.lods[Y].parts[fe]=ke});return function(j,X,Y,ne){return k.apply(this,arguments)}}());for(const k of b.lods)k.parts=k.parts.filter(j=>!!j);return{model:b,meta:{isEsriSymbolResource:C,uri:d.uri},customMeta:{}}}),Le.apply(this,arguments)}function te(x){let h=null;return x.json.nodes.forEach(y=>{const d=y.extras;(0,Z.pC)(d)&&(d.ESRI_proxyEllipsoid||d.ESRI_lod)&&(h=d)}),h}function he(x,a){return Oe.apply(this,arguments)}function Oe(){return Oe=(0,B.Z)(function*(x,a){const h=x.json,y=h.scenes[h.scene||0].nodes,d=y.length>1,_=[];for(const z of y){const k=h.nodes[z];_.push(b(z,0)),ue(k)&&!d&&k.extensions.MSFT_lod.ids.forEach((j,X)=>b(j,X+1))}function b(z,k){return C.apply(this,arguments)}function C(){return(C=(0,B.Z)(function*(z,k){const j=h.nodes[z],X=x.getNodeTransform(z);if(O.warnUnsupportedIf(null!=j.weights,"Morph targets are not supported."),null!=j.mesh){const Y=h.meshes[j.mesh];for(const ne of Y.primitives)_.push(a(ne,X,k,Y.name))}for(const Y of j.children||[])_.push(b(Y,k))})).apply(this,arguments)}yield Promise.all(_)}),Oe.apply(this,arguments)}function ue(x){return x.extensions&&x.extensions.MSFT_lod&&Array.isArray(x.extensions.MSFT_lod.ids)}function v(x,a,h){const y=_=>{const b=`${h}_tex_${_&&_.id}${_&&_.name?"_"+_.name:""}`;if(_&&!x.textures.has(b)){const C=function T(x,a={}){return{data:x,parameters:le({wrap:le({s:10497,t:10497},a.wrap),noUnpackFlip:!0,mipmap:!1},a)}}(_.data,{wrap:{s:_.wrapS,t:_.wrapT},mipmap:I.some(z=>z===_.minFilter),noUnpackFlip:!0});x.textures.set(b,C)}return b},d=`${h}_mat_${a.id}_${a.name}`;if(!x.materials.has(d)){const _=function M(x={}){return le({color:[1,1,1],opacity:1,alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1,castShadows:!0,receiveShadows:!0,receiveAmbientOcclustion:!0,textureColor:null,textureNormal:null,textureOcclusion:null,textureEmissive:null,textureMetallicRoughness:null,emissiveFactor:[0,0,0],metallicFactor:1,roughnessFactor:1,colorMixMode:"multiply"},x)}({color:[a.color[0],a.color[1],a.color[2]],opacity:a.color[3],alphaMode:a.alphaMode,alphaCutoff:a.alphaCutoff,doubleSided:a.doubleSided,colorMixMode:a.ESRI_externalColorMixMode,textureColor:a.colorTexture?y(a.colorTexture):void 0,textureNormal:a.normalTexture?y(a.normalTexture):void 0,textureOcclusion:a.occlusionTexture?y(a.occlusionTexture):void 0,textureEmissive:a.emissiveTexture?y(a.emissiveTexture):void 0,textureMetallicRoughness:a.metallicRoughnessTexture?y(a.metallicRoughnessTexture):void 0,emissiveFactor:[a.emissiveFactor[0],a.emissiveFactor[1],a.emissiveFactor[2]],metallicFactor:a.metallicFactor,roughnessFactor:a.roughnessFactor});x.materials.set(d,_)}return d}const O=new class E{error(a){throw new H.Z("gltf-loader-error",a)}errorUnsupported(a){throw new H.Z("gltf-loader-unsupported-feature",a)}errorUnsupportedIf(a,h){a&&this.errorUnsupported(h)}assert(a,h){a||this.error(h)}warn(a){U.warn(a)}warnUnsupported(a){this.warn("[Unsupported Feature] "+a)}warnUnsupportedIf(a,h){a&&this.warnUnsupported(h)}},I=[9987,9985],F=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"]},73825:(q,V,S)=>{S.d(V,{NO:()=>je,cM:()=>De,p:()=>Ie,DX:()=>Me});var B=S(84161),Z=S(28093),W=S(97535);function Te(v,O,I){return(0,B.f)(ge,O,v),(0,B.f)(ve,I,v),(0,B.l)((0,B.c)(ge,ge,ve))/2}S(67831),S(21286),S(26242),(0,Z.c)(),(0,Z.c)(),new W.x(()=>({origin:null,vector:null})),new W.x(function E(v){return v?{origin:(0,Z.a)(v.origin),vector:(0,Z.a)(v.vector)}:{origin:(0,Z.c)(),vector:(0,Z.c)()}}),new W.x(()=>({p0:null,p1:null,p2:null}));const ge=(0,Z.c)(),ve=(0,Z.c)();let ie=(()=>{const v=new Uint32Array(131072);for(let O=0;O<v.length;++O)v[O]=O;return v})();const me=new Uint16Array([0]),Ue=(()=>{const v=new Uint16Array(65536);for(let O=0;O<v.length;++O)v[O]=O;return v})();function Ie(v){if(1===v)return me;if(v<Ue.length)return new Uint16Array(Ue.buffer,0,v);if(v>ie.length){const O=Math.max(2*ie.length,v);ie=new Uint32Array(O);for(let I=0;I<ie.length;I++)ie[I]=I}return new Uint32Array(ie.buffer,0,v)}function Me(v){if(1===v)return new Uint16Array(me);if(v<Ue.length)return new Uint16Array(Ue.slice(0,v));if(v>ie.length){const O=new Uint32Array(v);for(let I=0;I<O.length;I++)O[I]=I;return O}return new Uint32Array(ie.slice(0,v))}function De(v,O,I){if(!v)return!1;const{size:F,data:x}=v;(0,B.s)(I,0,0,0),(0,B.s)(ue,0,0,0);let a=0,h=0;for(let y=0;y<O.length-2;y+=3){const d=O[y+0]*F,_=O[y+1]*F,b=O[y+2]*F;(0,B.s)(te,x[d+0],x[d+1],x[d+2]),(0,B.s)(he,x[_+0],x[_+1],x[_+2]),(0,B.s)(Oe,x[b+0],x[b+1],x[b+2]);const C=Te(te,he,Oe);C?((0,B.b)(te,te,he),(0,B.b)(te,te,Oe),(0,B.a)(te,te,1/3*C),(0,B.b)(I,I,te),a+=C):((0,B.b)(ue,ue,te),(0,B.b)(ue,ue,he),(0,B.b)(ue,ue,Oe),h+=3)}return!(0===h&&0===a||(0!==a?((0,B.a)(I,I,1/a),0):0===h||((0,B.a)(I,ue,1/h),0)))}function je(v,O,I){if(!v||!O)return!1;const{size:F,data:x}=v;(0,B.s)(I,0,0,0);let a=-1,h=0;for(let y=0;y<O.length;y++){const d=O[y]*F;a!==d&&(I[0]+=x[d+0],I[1]+=x[d+1],I[2]+=x[d+2],h++),a=d}return h>1&&(0,B.a)(I,I,1/h),h>0}const te=(0,Z.c)(),he=(0,Z.c)(),Oe=(0,Z.c)(),ue=(0,Z.c)()},79331:(q,V,S)=>{S.d(V,{K:()=>B});const B=2.1}}]);